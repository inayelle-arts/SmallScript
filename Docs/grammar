<SYNTAX>			::=	decl <EOL> { <DECL_LIST_ALIAS> } <EOL> impl <EOL> { <IMPL_LIST_ALIAS> }											
<EOL>				::=	\n | \r\n											
<DECL_LIST>			::=	<DECL_LIST> <DECL> | <DECL>									
<DECL>				::=	declare <VAR> as int of <CONST> <EOL>							
<IMPL_LIST>			::=	<IMPL_LIST> <IMPL> | <IMPL>											
<IMPL>				::=	<COND_IF> <EOL> | <LOOP> <EOL> | <ASSIGN> <EOL> | <READ> <EOL> | <WRITE> <EOL>						
<SIGN_0>			::=	+ | -											
<SIGN_1>			::=	* | /											
<MATH_0>			::=	<MATH_0_ALIAS_2> <SIGN_0> <MATH_1_ALIAS> | <MATH_1_ALIAS_2>											
<MATH_1>			::=	<MATH_1> <SIGN_1> <MATH_2_ALIAS> | <MATH_2_ALIAS_2>											
<MATH_2>			::=	<MATH_2> ** <MATH_0_ALIAS> | ( <MATH_0_ALIAS> ) | <VAR> | <CONST> | <SIGN_0> <MATH_0_ALIAS>		
<REL>				::= > | < | >= | <= | == | !=							
<BOOL>				::=	[ <MATH_0_ALIAS> <REL> <MATH_0_ALIAS> ]											
<COND_IF>			::=	if <BOOL> then do { <IMPL_LIST_ALIAS> } else do { <IMPL_LIST_ALIAS> } fi											
<LOOP>				::=	for <VAR> by <MATH_0_ALIAS> to <MATH_0_ALIAS> do { <IMPL_LIST_ALIAS> } rof											
<ASSIGN>			::=	let <VAR> be <ASSIGNMENT>											
<ASSIGNMENT>		::=	<MATH_0> | among <BOOL> ? <MATH_0_ALIAS> : <MATH_0_ALIAS>											
<READ>				::=	stdin >> <READ_LIST>								
<READ_LIST>			::=	<VAR> >> <READ_LIST> | <VAR> .					
<WRITE>				::=	stdout << <WRITE_LIST>						
<WRITE_LIST>		::=	<MATH_0_ALIAS> << <WRITE_LIST> | <MATH_0_ALIAS> .
#aliases						
<DECL_LIST_ALIAS>	::=	<DECL_LIST>											
<IMPL_LIST_ALIAS>	::=	<IMPL_LIST>											
<MATH_0_ALIAS>		::=	<MATH_0>											
<MATH_0_ALIAS_2>	::=	<MATH_0>											
<MATH_1_ALIAS>		::=	<MATH_1>											
<MATH_1_ALIAS_2>	::=	<MATH_1>											
<MATH_2_ALIAS>		::=	<MATH_2>											
<MATH_2_ALIAS_2>	::=	<MATH_2>